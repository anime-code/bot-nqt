const { Client, GatewayIntentBits, Partials, SlashCommandBuilder, EmbedBuilder } = require('discord.js');
const schedule = require('node-schedule');
const winston = require('winston');
require('dotenv').config();

// Custom transport ƒë·ªÉ g·ª≠i log t·ªõi Discord
class DiscordTransport extends winston.transports.Console {
    constructor(options) {
        super(options);
        this.name = 'discord';
        this.level = options.level || 'info';
    }

    async log(info, callback) {
        const { timestamp, level, message } = info;
        const logMessage = `${timestamp} [${level.toUpperCase()}]: ${message}`;
        if (this.logChannel) {
            try {
                await this.logChannel.send(logMessage);
            } catch (err) {
                console.error(`‚ùå L·ªói khi g·ª≠i log t·ªõi Discord: ${err.message}`);
            }
        }
        callback();
    }
}

// Kh·ªüi t·∫°o logger v·ªõi DiscordTransport
const logger = winston.createLogger({
    level: 'info',
    format: winston.format.combine(
        winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
        winston.format.printf(({ timestamp, level, message }) => `${timestamp} [${level.toUpperCase()}]: ${message}`)
    ),
    transports: [
        new winston.transports.Console(),
        new winston.transports.File({ filename: 'bot.log' }),
        new DiscordTransport({ level: 'info' }),
    ],
});

const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
    ],
    partials: [Partials.Channel],
});

// H√†m t·∫°o Embed ng·∫´u nhi√™n cho th√¥ng b√°o ngh·ªâ tr∆∞a
const getRandomLunchEmbed = () => {
    const lunchMessages = [
        {
            description: 'üçú **T√®n ten!** ƒê·∫øn gi·ªù **ngh·ªâ tr∆∞a** r·ªìi n√®! üòã ƒêi ƒÉn ph·ªü hay b√∫n g√¨ ngon ƒëi, 12:00 tr∆∞a r√πi! ü•≥',
            thumbnail: 'https://i.imgur.com/5Z9e7yK.png' // H√¨nh b√°t ph·ªü
        },
        {
            description: 'üçî **12:00 tr∆∞a** r·ªìi! Gi·ªù **ngh·ªâ tr∆∞a** n√®, ai ƒÉn burger, ai ƒÉn c∆°m t·∫•m ƒë√¢y? üòé Let‚Äôs go! üéà',
            thumbnail: 'https://i.imgur.com/8kXjW3n.png' // H√¨nh burger
        },
        {
            description: 'üç£ **Ngh·ªâ tr∆∞a** th√¥i n√†o! Sushi, b√°nh x√®o hay tr√† s·ªØa, ch·ªçn g√¨ ƒë√¢y? üòã **12:00** nha m·ªçi ng∆∞·ªùi! üö¥‚Äç‚ôÇÔ∏è',
            thumbnail: 'https://i.imgur.com/4fY2m9R.png' // H√¨nh sushi
        }
    ];
    return lunchMessages[Math.floor(Math.random() * lunchMessages.length)];
};

// M·∫£ng reminders v·ªõi Embeds
const reminders = [
    {
        time: '0 59 8 * * 1-5',
        embed: () => new EmbedBuilder()
            .setTitle('üåû **ASAKAI TIME!**')
            .setDescription('üöÄ **S√°ng r·ª±c r·ª° r·ªìi!** M·ªçi ng∆∞·ªùi s·∫µn s√†ng h·ªçp ASAKAI ch∆∞a? üí™ **8:59 s√°ng** n√®, v√†o th√¥i n√†o! üéâ')
            .setColor('#FFD700') // M√†u v√†ng s√°ng
            .addFields(
                { name: '‚è∞ Th·ªùi gian', value: '8:59 AM', inline: true },
                { name: 'üìç K√™nh h·ªçp', value: 'Ki·ªÉm tra Zoom/Discord nha!', inline: true }
            )
            .setThumbnail('https://i.imgur.com/3xY9Z2k.png') // H√¨nh m·∫∑t tr·ªùi
            .setFooter({ text: 'Bot nh·∫Øc nh·ªü si√™u x·ªãn by NQT', iconURL: client.user.displayAvatarURL() })
            .setTimestamp()
    },
    {
        time: '0 55 11 * * 1-5',
        embed: () => {
            const { description, thumbnail } = getRandomLunchEmbed();
            return new EmbedBuilder()
                .setTitle('üç¥ **GI·ªú NGH·ªà TR∆ØA!**')
                .setDescription(description)
                .setColor('#00FF7F') // M√†u xanh l√° t∆∞∆°i
                .addFields(
                    { name: '‚è∞ Th·ªùi gian', value: '11:55 PM', inline: true },
                    { name: 'üçΩ G·ª£i √Ω', value: 'ƒÇn g√¨ ngon th√¨ share nha!', inline: true }
                )
                .setThumbnail(thumbnail)
                .setFooter({ text: 'Bot nh·∫Øc nh·ªü si√™u x·ªãn by NQT', iconURL: client.user.displayAvatarURL() })
                .setTimestamp();
        }
    },
    {
        time: '0 45 16 * * 1-5',
        embed: () => new EmbedBuilder()
            .setTitle('üìù **H·∫æU H·∫æU! DAILY REPORT TIME!**')
            .setDescription('‚è∞ **16:55 chi·ªÅu** r·ªìi n√®! ƒê·ª´ng qu√™n **b√°o c√°o ng√†y** nha m·ªçi ng∆∞·ªùi! üìä Nhanh tay v√†o link b√°o c√°o n√†o! üí™')
            .setColor('#FF4500') // M√†u cam n·ªïi b·∫≠t
            .addFields(
                { name: '‚è∞ Th·ªùi gian', value: '4:55 PM', inline: true },
                { name: 'üîó Link b√°o c√°o', value: '[Work Report](https://work-report.thk-hd-hn.vn/)', inline: true }
            )
            .setThumbnail('https://i.imgur.com/7pX8q9L.png') // H√¨nh checklist
            .setFooter({ text: 'Bot nh·∫Øc nh·ªü si√™u x·ªãn by NQT', iconURL: client.user.displayAvatarURL() })
            .setTimestamp()
    }
];

// C·∫≠p nh·∫≠t retrySendMessage ƒë·ªÉ h·ªó tr·ª£ c·∫£ chu·ªói v√† embeds
const retrySendMessage = async (channel, content, retries = 3, delay = 5000) => {
    for (let i = 0; i < retries; i++) {
        try {
            if (typeof content === 'string') {
                await channel.send({ content });
            } else {
                await channel.send({ content: '@everyone', embeds: [content] });
            }
            return true;
        } catch (err) {
            logger.error(`‚ùå L·ªói khi g·ª≠i tin nh·∫Øn (l·∫ßn ${i + 1}/${retries}): ${err.message}, Channel ID: ${channel?.id || 'Kh√¥ng x√°c ƒë·ªãnh'}`);
            if (i < retries - 1) {
                logger.info(`‚è≥ Th·ª≠ l·∫°i sau ${delay / 1000} gi√¢y...`);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    return false;
};

client.once('ready', async () => {
    console.log(`‚úÖ Bot ${client.user.tag} ƒë√£ s·∫µn s√†ng!`);
    logger.info(`‚è∞ Th·ªùi gian hi·ªán t·∫°i khi kh·ªüi ƒë·ªông: ${new Date().toString()}`);

    const channel = client.channels.cache.get(process.env.CHANNEL_ID);
    const logChannel = client.channels.cache.get(process.env.LOG_CHANNEL_ID);

    if (!channel) {
        console.error('‚ùå Kh√¥ng t√¨m th·∫•y k√™nh ch√≠nh! Ki·ªÉm tra l·∫°i CHANNEL_ID.');
        logger.error('‚ùå Kh√¥ng t√¨m th·∫•y k√™nh ch√≠nh! Ki·ªÉm tra l·∫°i CHANNEL_ID.');
        return;
    }

    if (!logChannel) {
        console.error('‚ùå Kh√¥ng t√¨m th·∫•y k√™nh log! Ki·ªÉm tra l·∫°i LOG_CHANNEL_ID.');
        logger.error('‚ùå Kh√¥ng t√¨m th·∫•y k√™nh log! Ki·ªÉm tra l·∫°i LOG_CHANNEL_ID.');
    } else {
        logger.transports.find(transport => transport instanceof DiscordTransport).logChannel = logChannel;
    }

    // L√™n l·ªãch g·ª≠i log m·ªói 1 gi·ªù
    schedule.scheduleJob('log-every-hour', '0 * * * *', async () => {
        if (logChannel) {
            const logMessage = `üìä [STATUS] Bot ƒëang ho·∫°t ƒë·ªông. S·ªë nh·∫Øc nh·ªü: ${reminders.length}. Th·ªùi gian: ${new Date().toString()}`;
            const success = await retrySendMessage(logChannel, logMessage);
            if (success) {
                logger.info(`‚úÖ ƒê√£ g·ª≠i log tr·∫°ng th√°i ƒë·ªãnh k·ª≥`);
            } else {
                logger.error(`‚ùå Kh√¥ng th·ªÉ g·ª≠i log tr·∫°ng th√°i ƒë·ªãnh k·ª≥`);
            }
        }
    });
    logger.info('üìÖ ƒê√£ l√™n l·ªãch log tr·∫°ng th√°i m·ªói 1 gi·ªù');

    // L√™n l·ªãch c√°c nh·∫Øc nh·ªü
    reminders.forEach((reminder, index) => {
        schedule.scheduleJob(`reminder-${index}`, reminder.time, async () => {
            logger.info(`‚è∞ ƒêang ch·∫°y l·ªãch tr√¨nh nh·∫Øc nh·ªü ${index + 1} v√†o ${new Date().toString()}`);
            logger.info(`üîç K√™nh ch√≠nh: ${channel ? channel.id : 'Kh√¥ng t√¨m th·∫•y'}`);
            const success = await retrySendMessage(channel, reminder.embed());
            if (success) {
                logger.info(`‚úÖ ƒê√£ g·ª≠i nh·∫Øc nh·ªü: ${reminder.embed().data.description}`);
            } else {
                logger.error(`‚ùå Kh√¥ng th·ªÉ g·ª≠i nh·∫Øc nh·ªü sau nhi·ªÅu l·∫ßn th·ª≠`);
            }
        });
        logger.info(`üìÖ ƒê√£ l√™n l·ªãch nh·∫Øc nh·ªü ${index + 1} v√†o ${reminder.time}`);
    });

    // ƒêƒÉng k√Ω l·ªánh slash
    try {
        const commands = [
            new SlashCommandBuilder()
                .setName('status')
                .setDescription('Ki·ªÉm tra tr·∫°ng th√°i c·ªßa bot'),
        ];
        await client.application.commands.set(commands);
        logger.info('‚úÖ ƒê√£ ƒëƒÉng k√Ω l·ªánh slash');
    } catch (err) {
        logger.error(`‚ùå L·ªói khi ƒëƒÉng k√Ω l·ªánh slash: ${err.message}`);
    }
});

// X·ª≠ l√Ω l·ªánh slash
client.on('interactionCreate', async (interaction) => {
    if (!interaction.isCommand()) return;

    if (interaction.commandName === 'status') {
        await interaction.reply({
            content: `‚úÖ Bot ƒëang ho·∫°t ƒë·ªông! Hi·ªán t·∫°i c√≥ ${reminders.length} nh·∫Øc nh·ªü ƒë∆∞·ª£c l√™n l·ªãch. Th·ªùi gian: ${new Date().toString()}`,
            ephemeral: true,
        });
        logger.info(`üì° L·ªánh /status ƒë∆∞·ª£c g·ªçi b·ªüi ${interaction.user.tag}`);
    }
});

// X·ª≠ l√Ω l·ªói
client.on('error', (err) => {
    logger.error(`‚ùå L·ªói client Discord: ${err.message}`);
});

client.on('disconnect', () => {
    logger.warn('‚ö† Bot ƒë√£ ng·∫Øt k·∫øt n·ªëi, ƒëang th·ª≠ k·∫øt n·ªëi l·∫°i...');
});

client.on('reconnecting', () => {
    logger.info('üîÑ Bot ƒëang k·∫øt n·ªëi l·∫°i...');
});

// ƒêƒÉng nh·∫≠p bot
const loginBot = async () => {
    try {
        if (!process.env.DISCORD_TOKEN) {
            logger.error('‚ùå DISCORD_TOKEN kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y trong file .env!');
            process.exit(1);
        }
        if (!process.env.LOG_CHANNEL_ID) {
            logger.error('‚ùå LOG_CHANNEL_ID kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y trong file .env!');
        }
        await client.login(process.env.DISCORD_TOKEN);
        logger.info('‚úÖ ƒêƒÉng nh·∫≠p bot th√†nh c√¥ng');
    } catch (err) {
        logger.error(`‚ùå L·ªói ƒëƒÉng nh·∫≠p bot: ${err.message}`);
        process.exit(1);
    }
};
loginBot();

// Express server
const express = require('express');
const app = express();
const PORT = process.env.PORT || 3000;

app.get('/', (req, res) => res.send('Bot ƒëang ch·∫°y!'));

app.listen(PORT, () => {
    logger.info(`‚úÖ Server Express ch·∫°y tr√™n port ${PORT}`);
});

// X·ª≠ l√Ω khi bot b·ªã t·∫Øt
process.on('SIGINT', () => {
    logger.info('üì¥ Bot ƒëang t·∫Øt...');
    schedule.gracefulShutdown().then(() => {
        logger.info('üìÖ ƒê√£ h·ªßy t·∫•t c·∫£ l·ªãch tr√¨nh');
        client.destroy();
        process.exit(0);
    });
});